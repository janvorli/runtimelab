# Experiment: Evaluate the Mono interpreter
The goal of this experiment is to evaluate usability of the Mono interpreter as a standalone component that can be used for CoreCLR, NativeAOT and possibly others. Its goal is to give answers to the following questions:
* Is the existing byte code the interpreter uses as an internal representation reasonable? Should it be changed in any way?
* What should be the interface between the interpreter, a runtime, a GC and the debugger?
* How do we abstract the runtime specific dependencies?
* What frontend should be used for coreclr?
* What executor should be used for coreclr?
* How should transitions between the interpreter and runtime / AOT code work?

The expected outcome of the experiment is a set of documents, no coding will be done.
The documentation should also allow us to estimate the amount of work needed to move the interpreter to the recommended state.

## Basic structure of the Mono interpreter
### Transformation phase
This phase converts IL into an intermediate representation. Most of the IR byte codes directly match the IL opcodes. The main difference is in how arguments are referenced. On contrary to IL where the IL opcodes use implicitly last N pushed values on the stack as arguments, the IR explicitly contains values or references to local variables, arguments, etc.
Besides a trivial translation of IL opcodes to matching IR byte codes, the transformation phase also performs some basic constant folding. For example, ldc.1 followed by add is transformed into MINT_ADD1_I4. Some IL opcodes are converted to specialized variants of IR opcodes based on what's on the stack. So for example CEE_CONV_U1 can become MINT_CONV_U1_R4, MINT_CONV_U1_R8, MINT_CONV_U1_I4 or MINT_CONV_U1_I8.

The transformation phase can also inline IR of a callee into a caller. 

When running with debugger connected, MINT_SDB_SEQ_POINT IR instruction is injected at every sequence point. That instruction is dummy, but the debugger can overwrite it by MINT_SDB_BREAKPOINT instruction when it needs to set a breakpoint in the interpreted code.

When optimizations are turned on, additional more complex optimizations are performed. SSA is used during the process. The optimizations that can be performed are as follows: 

 * Removing stores to vars that are not read after
 * Constant folding 
 * Binary ops with constants only
 * Unary ops with constants
 * ldc + ret -> ret.imm
 * Ldc + add / mul / or / and -> ins.imm
 * ldc + sub -> add.-imm - what is the benefit of saving one instr here?
 * ldc + sh -> sh.imm
 * ldc + div.un -> shr.imm
 * MINT_LDIND_I1 + MINT_ADD_P -> MINT_LDIND_OFFSET_I1
 * Similar with STIND
 * MINT_LDIND_I1 + MINT_ADD_P_IMM -> MINT_LDIND_OFFSET_IMM_I1
 * MINT_LDIND_OFFSET_I1 + MINT_MUL_P_IMM / MINT_ADD_P_IMM / MINT_ADD_MUL_P_IMM -> MINT_LDIND_OFFSET_ADD_MUL_IMM_I1
 * cknull + ldfld -> ldfld
 * MINT_SAFEPOINT folding into some instructions, forming _SP variants
 * MINT_LDOBJ_VT + MINT_STOBJ_VT_NOREF -> MINT_CPOBJ_VT_NOREF
 * SIMD intrinsics

### Execution phase
The execution phase executes the IR bytecode generated by the transformation phase. It is essentially a loop with a giant switch statement with cases for all the IR opcodes. Code for each case extracts values of arguments of the specific IR instruction from the byte code and the local variables / per method data items tables and then it performs the specific operation. Some of them, like arithmetic operations or branches are trivial, resulting in execution of only a couple of machine code instructions, some of them like calls are quite complex.
There is also support for tiering when a frequently executed method with non-optimized IR can be transformed again with optimizations turned on.

## Analysis results and plans for CoreCLR
The following documents describe the mapping of the IL opcodes to the IR opcodes, the Mono APIs used by the transformation and execution phases and how the debugger cooperates with the interpreter. They also describe the way these should work in CoreCLR.
* [IR byte code](ir-byte-code.md)
* TODO: Interpreter Mono runtime dependencies (Vlad - commit the gist he has initially created)
* [Transformation phase analysis](transformation.md)
* [Execution phase analysis](execution.md)
* [Debugger integration](debugger.md)
* [Stack walking for GC, exception handling and debugger](stackwalk.md)
* [Precise GC in the interpreter](precise-gc.md)
* [Interop of the interpreter with compiled managed code](compiled-code-interop.md)
* [CoreCLR exception handling integration with the interpreter](exception-handling.md)
* TODO: link doc on Calls, delegates, function pointers (Vlad)
